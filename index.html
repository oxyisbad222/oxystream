<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SkyeMovie</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #141414;
            color: #e5e5e5;
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #232323; }
        ::-webkit-scrollbar-thumb { background: #e50914; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #f40612; }

        .netflix-red-text { color: #e50914; }
        .input-field, .select-field {
            background-color: #333; border: 1px solid #555; color: #fff;
            border-radius: 0.25rem; padding: 0.5rem 0.75rem;
            transition: border-color 0.2s ease-in-out; width: 100%;
        }
        .input-field:focus, .select-field:focus { outline: none; border-color: #e50914; }
        
        .card {
            background-color: #1f1f1f; border-radius: 0.5rem;
            overflow: hidden; transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            width: 180px; 
            flex-shrink: 0; 
        }
        .card:hover { transform: scale(1.05); box-shadow: 0 10px 20px rgba(0,0,0,0.5); }
        .card img { width: 100%; height: 270px; object-fit: cover; }
        
        .iframe-container { 
            position: relative; 
            overflow: hidden; 
            width: 100%; 
            padding-top: 56.25%; 
            background-color: #000; 
            flex-grow: 1; 
        }
        .iframe-container iframe { position: absolute; top: 0; left: 0; bottom: 0; right: 0; width: 100%; height: 100%; border: none; }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.85); }
        .modal-content { 
            background-color: #181818; 
            padding: 10px; 
            border-radius: 8px;
            width: 95vw; 
            max-width: 900px; 
            margin: 2.5vh auto; 
            max-height: 95vh; 
            display: flex; 
            flex-direction: column;
            position: relative; 
        }
        .close-button { 
            color: #aaa; 
            font-size: 32px; 
            font-weight: bold; 
            cursor: pointer; 
            line-height: 1;
            position: absolute; 
            top: 10px;
            right: 15px;
            z-index: 1001; 
        }
        .close-button:hover, .close-button:focus { color: #e50914; text-decoration: none; }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #e50914;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .horizontal-scroll-container { position: relative; }
        .scroll-wrapper {
            display: flex; overflow-x: auto; scroll-behavior: smooth; padding-bottom: 1rem; 
            -ms-overflow-style: none; scrollbar-width: none;  
        }
        .scroll-wrapper::-webkit-scrollbar { display: none; }
        .scroll-button {
            position: absolute; top: 50%; transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.6); color: white; border: none;
            padding: 0.8rem 0.5rem; cursor: pointer; z-index: 10;
            border-radius: 0.25rem; font-size: 1.5rem; line-height: 1;
            opacity: 0.7; transition: opacity 0.2s;
        }
        .scroll-button:hover { opacity: 1; }
        .scroll-button.prev { left: 5px; }
        .scroll-button.next { right: 5px; }
        .scroll-button:disabled { opacity:0.3; cursor: not-allowed;}

        #modalTvControls { background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; margin-top: 10px; }
        .btn-next-episode {
            background-color: #e50914; color: white; font-weight: bold;
            padding: 0.5rem 1rem; border-radius: 0.25rem;
            transition: background-color 0.2s ease-in-out; cursor: pointer; border: none;
        }
        .btn-next-episode:hover { background-color: #f40612; }
        .btn-next-episode:disabled { background-color: #555; cursor: not-allowed; }
        
        #searchResultsGrid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 1rem; }
        #searchResultsGrid .card { width: 100%; }

        .filter-btn {
            padding: 0.4rem 0.8rem; border-radius: 0.25rem; border: 1px solid #555;
            background-color: #333; color: #ccc; cursor: pointer;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            font-size: 0.875rem;
        }
        .filter-btn:hover { background-color: #444; }
        .filter-btn.active { background-color: #e50914; color: white; border-color: #e50914; }

        @media (max-width: 768px) {
            .modal-content {
                width: 100vw;
                height: 100vh; 
                max-height: 100vh; 
                margin: 0;
                border-radius: 0;
                padding: 5px; 
            }
            .close-button { 
                background-color: rgba(0,0,0,0.5);
                border-radius: 50%;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                top: 8px; 
                right: 8px;
            }
            #playerModalTitle {
                font-size: 1rem; 
                margin-bottom: 5px;
                padding-right: 35px; 
            }
            #modalTvControls {
                padding: 5px;
                margin-top: 8px;
            }
            #modalTvControls .select-field, #modalTvControls .btn-next-episode {
                font-size: 0.75rem; 
                padding: 0.35rem 0.5rem;
            }
            #modalTvControls label {
                font-size: 0.75rem;
            }
            .modal-content > p.text-xs { 
                font-size: 0.65rem;
                margin-top: 5px;
            }
        }
    </style>
</head>
<body class="text-gray-200">

    <header class="bg-black bg-opacity-90 shadow-lg sticky top-0 z-50 backdrop-blur-md">
        <div class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-20">
                <a href="#" id="homeLink" class="text-3xl font-bold netflix-red-text">SkyeMovie</a>
                <div class="hidden md:flex flex-grow items-center max-w-2xl mx-4">
                    <div class="relative w-full">
                        <input type="text" id="desktopSearchInput" class="input-field w-full pr-10" placeholder="Search...">
                        <button id="desktopSearchButton" class="absolute inset-y-0 right-0 px-3 text-gray-400 hover:text-e50914">
                            <i class="fas fa-search"></i>
                        </button>
                    </div>
                    <div id="desktopSearchFilters" class="flex space-x-2 ml-3">
                        <button class="filter-btn active" data-filter="multi">All</button>
                        <button class="filter-btn" data-filter="movie">Movies</button>
                        <button class="filter-btn" data-filter="tv">TV</button>
                    </div>
                </div>
                <div class="md:hidden">
                    <button id="mobileMenuButton" class="text-gray-300 hover:text-white focus:outline-none">
                        <i class="fas fa-bars text-2xl"></i>
                    </button>
                </div>
            </div>
        </div>
        <div id="mobileMenu" class="md:hidden hidden bg-black bg-opacity-90 p-4 space-y-3">
            <div class="relative w-full">
                 <input type="text" id="mobileSearchInput" class="input-field w-full pr-10" placeholder="Search...">
                 <button id="mobileSearchButton" class="absolute inset-y-0 right-0 px-3 text-gray-400 hover:text-e50914">
                     <i class="fas fa-search"></i>
                 </button>
            </div>
            <div id="mobileSearchFilters" class="flex justify-center space-x-2">
                <button class="filter-btn active" data-filter="multi">All</button>
                <button class="filter-btn" data-filter="movie">Movies</button>
                <button class="filter-btn" data-filter="tv">TV</button>
            </div>
            <a href="#" id="navDiscoverMobile" class="block text-center py-2 hover:bg-gray-700 rounded-md">Discover Top Rated</a>
        </div>
    </header>
    
    <main class="container mx-auto p-4 sm:p-6 lg:p-8" id="mainContent">
        <div id="statusMessage" class="text-center my-4 h-6"></div>
        <section id="discoverSection"> 
            <h2 id="contentAreaTitle" class="text-3xl font-bold mb-6 border-l-4 border-red-600 pl-3">Top Rated</h2>
            
            <div id="moviesContainer" class="mb-10">
                <h3 class="text-2xl font-semibold mb-4">Movies</h3>
                <div class="horizontal-scroll-container">
                    <button class="scroll-button prev" data-target="moviesScrollWrapper"><i class="fas fa-chevron-left"></i></button>
                    <div id="moviesScrollWrapper" class="scroll-wrapper flex space-x-4"></div>
                    <button class="scroll-button next" data-target="moviesScrollWrapper"><i class="fas fa-chevron-right"></i></button>
                </div>
            </div>

            <div id="tvShowsContainer">
                <h3 class="text-2xl font-semibold mb-4">TV Shows</h3>
                 <div class="horizontal-scroll-container">
                    <button class="scroll-button prev" data-target="tvScrollWrapper"><i class="fas fa-chevron-left"></i></button>
                    <div id="tvScrollWrapper" class="scroll-wrapper flex space-x-4"></div>
                    <button class="scroll-button next" data-target="tvScrollWrapper"><i class="fas fa-chevron-right"></i></button>
                </div>
            </div>
            <div id="searchResultsGridContainer" class="hidden mt-8">
                <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-2">
                    <h2 id="searchResultsTitle" class="text-2xl font-semibold">Search Results</h2>
                    <select id="sortResultsSelect" class="select-field w-full sm:w-auto text-sm py-1.5">
                        <option value="popularity.desc">Sort by Popularity</option>
                        <option value="date.desc">Date (New to Old)</option>
                        <option value="date.asc">Date (Old to New)</option>
                    </select>
                </div>
                <div id="searchResultsGrid"></div>
            </div>
        </section>
    </main>

    <div id="playerModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-start mb-2">
                <h3 id="playerModalTitle" class="text-xl font-semibold">Now Playing</h3>
                <span class="close-button" id="closeModalButton">&times;</span>
            </div>
            <div id="playerContainer" class="iframe-container"></div>
            
            <div id="modalTvControls" class="hidden">
                <h4 id="modalTvShowTitle" class="text-md font-semibold mb-2"></h4>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 items-center">
                    <div class="flex items-center gap-2">
                        <label for="modalSeasonSelect" class="text-sm flex-shrink-0">Season:</label>
                        <select id="modalSeasonSelect" class="select-field text-sm"></select>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="modalEpisodeSelect" class="text-sm flex-shrink-0">Episode:</label>
                        <select id="modalEpisodeSelect" class="select-field text-sm"></select>
                    </div>
                    <button id="nextEpisodeButton" class="btn-next-episode text-sm sm:col-start-3">Next Episode <i class="fas fa-step-forward ml-1"></i></button>
                </div>
            </div>
            <p class="text-xs text-gray-400 mt-3">Using Server 4. We strive to keep advertising minimal to support the service and ensure a great viewing experience.</p>
        </div>
    </div>

    <footer class="text-center p-6 mt-12 border-t border-gray-700">
        <p class="text-sm text-gray-400">Welcome to SkyeMovie! For the latest updates and community chat, join us on Telegram:</p>
        <a href="https://t.me/skyemovieupdates" target="_blank" rel="noopener noreferrer" class="text-lg netflix-red-text hover:underline font-semibold">
            <i class="fab fa-telegram-plane mr-1"></i> SkyeMovie Updates
        </a>
        <p class="text-xs text-gray-500 mt-2">&copy; <span id="currentYear"></span> SkyeMovie.</p>
    </footer>

    <script>
        const TMDB_IMG_BASE_URL = 'https://image.tmdb.org/t/p/w500';
        const ANYEMBED_BASE_URL = "https://player.autoembed.cc/embed";
        const DEFAULT_SERVER = 4;

        const desktopSearchInput = document.getElementById('desktopSearchInput');
        const desktopSearchButton = document.getElementById('desktopSearchButton');
        const mobileSearchInput = document.getElementById('mobileSearchInput');
        const mobileSearchButton = document.getElementById('mobileSearchButton');
        const desktopSearchFilters = document.getElementById('desktopSearchFilters');
        const mobileSearchFilters = document.getElementById('mobileSearchFilters');
        const statusMessage = document.getElementById('statusMessage');
        
        const playerModal = document.getElementById('playerModal');
        const playerContainer = document.getElementById('playerContainer');
        const closeModalButton = document.getElementById('closeModalButton');
        const playerModalTitle = document.getElementById('playerModalTitle');

        const modalTvControls = document.getElementById('modalTvControls');
        const modalTvShowTitleEl = document.getElementById('modalTvShowTitle');
        const modalSeasonSelect = document.getElementById('modalSeasonSelect');
        const modalEpisodeSelect = document.getElementById('modalEpisodeSelect');
        const nextEpisodeButton = document.getElementById('nextEpisodeButton');

        const discoverSection = document.getElementById('discoverSection');
        const contentAreaTitle = document.getElementById('contentAreaTitle');
        const moviesContainer = document.getElementById('moviesContainer');
        const tvShowsContainer = document.getElementById('tvShowsContainer');
        const searchResultsGridContainer = document.getElementById('searchResultsGridContainer');
        const searchResultsTitle = document.getElementById('searchResultsTitle');
        const searchResultsGrid = document.getElementById('searchResultsGrid');
        const sortResultsSelect = document.getElementById('sortResultsSelect');


        let moviesScrollWrapper = document.getElementById('moviesScrollWrapper'); 
        let tvScrollWrapper = document.getElementById('tvScrollWrapper'); 
        
        const homeLink = document.getElementById('homeLink');
        const mobileMenuButton = document.getElementById('mobileMenuButton');
        const mobileMenu = document.getElementById('mobileMenu');
        const navDiscoverMobile = document.getElementById('navDiscoverMobile');

        let currentTvShow = { id: null, name: null, season: 1, episode: 1, totalSeasons: 0, episodesInCurrentSeason: [] };
        let seasonDetailsCache = {}; 
        let currentSearchFilter = 'multi'; 
        let currentSearchResults = [];
        let currentSearchQuery = '';


        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = 'text-center my-4 h-6 ';
            if (type === 'error') statusMessage.classList.add('text-red-400');
            else if (type === 'success') statusMessage.classList.add('text-green-400');
            else statusMessage.classList.add('text-gray-400');
        }

        function createLoadingSpinner() {
            const spinner = document.createElement('div');
            spinner.className = 'loading-spinner'; 
            return spinner;
        }

        async function fetchFromTMDB(tmdbEndpoint, tmdbParams = {}) {
            const proxyUrlParams = new URLSearchParams({ endpoint: tmdbEndpoint, ...tmdbParams });
            const proxyUrl = `/api/tmdb-proxy?${proxyUrlParams.toString()}`;
            try {
                const response = await fetch(proxyUrl);
                const contentType = response.headers.get("content-type");
                if (!response.ok) {
                    let errorPayload = { message: `Proxy API Error: ${response.status} ${response.statusText}`, status: response.status, contentType: contentType };
                    if (contentType && contentType.includes("application/json")) {
                        const errorData = await response.json().catch(() => ({}));
                        errorPayload.details = errorData.error || errorData.details || errorData.message || errorData;
                    } else {
                        errorPayload.rawResponse = await response.text().catch(() => "Could not read error response body.");
                    }
                    console.error("Proxy Error Payload:", errorPayload);
                    throw new Error(typeof errorPayload.details === 'string' ? errorPayload.details : errorPayload.message);
                }
                if (contentType && contentType.includes("application/json")) {
                    return await response.json();
                } else {
                    const rawText = await response.text().catch(() => "Could not read response body.");
                    console.error("Expected JSON from proxy, received:", contentType, rawText.substring(0, 200));
                    throw new Error(`Unexpected content type from proxy: ${contentType}. Expected JSON. Received: ${rawText.substring(0,100)}...`);
                }
            } catch (error) {
                console.error('Full error in fetchFromTMDB:', error);
                showStatus(error.message || "An unknown API error occurred.", 'error');
                throw error; 
            }
        }

        function sortAndDisplayResults() {
            let resultsToDisplay = [...currentSearchResults];
            const sortBy = sortResultsSelect.value;

            resultsToDisplay.sort((a, b) => {
                if (sortBy === 'popularity.desc') {
                    return (b.popularity || 0) - (a.popularity || 0);
                } else if (sortBy === 'date.desc') {
                    const dateA = new Date(a.release_date || a.first_air_date || '1900-01-01');
                    const dateB = new Date(b.release_date || b.first_air_date || '1900-01-01');
                    return dateB - dateA;
                } else if (sortBy === 'date.asc') {
                    const dateA = new Date(a.release_date || a.first_air_date || '3000-01-01');
                    const dateB = new Date(b.release_date || b.first_air_date || '3000-01-01');
                    return dateA - dateB;
                }
                return 0;
            });

            searchResultsGrid.innerHTML = '';
            if (resultsToDisplay.length === 0 && currentSearchQuery) {
                searchResultsGrid.innerHTML = `<p class="col-span-full text-center text-gray-400">No results found for "${currentSearchQuery}".</p>`;
                return;
            }
            resultsToDisplay.forEach(item => {
                 searchResultsGrid.appendChild(createContentCard(item, item.media_type));
            });
        }

        function displaySearchResultsUI(results, query) {
            moviesContainer.classList.add('hidden');
            tvShowsContainer.classList.add('hidden');
            contentAreaTitle.classList.add('hidden');
            searchResultsGridContainer.classList.remove('hidden');
            searchResultsTitle.textContent = `Search Results for "${query}"`;

            let processedResults = results.map(item => {
                if (currentSearchFilter === 'movie' && !item.media_type) {
                    return { ...item, media_type: 'movie' };
                } else if (currentSearchFilter === 'tv' && !item.media_type) {
                    return { ...item, media_type: 'tv' };
                }
                return item;
            });
            
            currentSearchResults = processedResults.filter(item => 
                (item.media_type === 'movie' || item.media_type === 'tv') && item.poster_path
            );
            
            sortResultsSelect.value = 'popularity.desc';
            sortAndDisplayResults();
        }

        async function executeSearch(query) {
            if (!query) return;
            currentSearchQuery = query; 
            showStatus('');
            contentAreaTitle.classList.add('hidden');
            moviesContainer.classList.add('hidden');
            tvShowsContainer.classList.add('hidden');
            searchResultsGridContainer.classList.remove('hidden');
            searchResultsTitle.textContent = `Searching for "${query}"...`;
            searchResultsGrid.innerHTML = '';
            searchResultsGrid.appendChild(createLoadingSpinner());

            let endpoint = 'search/multi';
            if (currentSearchFilter === 'movie') endpoint = 'search/movie';
            else if (currentSearchFilter === 'tv') endpoint = 'search/tv';
            
            try {
                const data = await fetchFromTMDB(endpoint, { query });
                displaySearchResultsUI(data.results || [], query);
            } catch (error) {
                searchResultsTitle.textContent = `Search Results`;
                searchResultsGrid.innerHTML = `<p class="col-span-full text-center text-red-400">Error during search. Please try again.</p>`;
            }
        }
        
        async function loadTopRatedContent() {
            showStatus('');
            contentAreaTitle.textContent = "Top Rated";
            contentAreaTitle.classList.remove('hidden');
            moviesContainer.classList.remove('hidden');
            tvShowsContainer.classList.remove('hidden');
            searchResultsGridContainer.classList.add('hidden');
            searchResultsGrid.innerHTML = '';

            if (!moviesScrollWrapper || !tvScrollWrapper) {
                reinitializeScrollableContent(); 
                if (!moviesScrollWrapper || !tvScrollWrapper) { 
                     showStatus("UI elements missing. Please refresh.", "error"); return;
                }
            }
            moviesScrollWrapper.innerHTML = ''; tvScrollWrapper.innerHTML = '';
            const movieSpinner = createLoadingSpinner(); const tvSpinner = createLoadingSpinner();
            moviesScrollWrapper.appendChild(movieSpinner); tvScrollWrapper.appendChild(tvSpinner);
            updateScrollButtons(moviesScrollWrapper); updateScrollButtons(tvScrollWrapper);

            try {
                const [moviesData, tvData] = await Promise.all([
                    fetchFromTMDB('movie/top_rated'), fetchFromTMDB('tv/top_rated')
                ]);
                moviesScrollWrapper.innerHTML = '';
                if (moviesData.results && moviesData.results.length > 0) {
                    moviesData.results.forEach(movie => moviesScrollWrapper.appendChild(createContentCard(movie, 'movie')));
                } else { moviesScrollWrapper.innerHTML = '<p class="p-4">Could not load top rated movies.</p>'; }
                updateScrollButtons(moviesScrollWrapper);

                tvScrollWrapper.innerHTML = '';
                if (tvData.results && tvData.results.length > 0) {
                    tvData.results.forEach(tvShow => tvScrollWrapper.appendChild(createContentCard(tvShow, 'tv')));
                } else { tvScrollWrapper.innerHTML = '<p class="p-4">Could not load top rated TV shows.</p>'; }
                updateScrollButtons(tvScrollWrapper);
            } catch (error) {
                 if (!moviesScrollWrapper.hasChildNodes() || moviesScrollWrapper.firstChild.classList.contains('loading-spinner')) {
                    moviesScrollWrapper.innerHTML = `<p class="p-4 text-red-400">Error loading movies.</p>`;
                 }
                 if (!tvScrollWrapper.hasChildNodes() || tvScrollWrapper.firstChild.classList.contains('loading-spinner')) {
                    tvScrollWrapper.innerHTML = `<p class="p-4 text-red-400">Error loading TV shows.</p>`;
                 }
            }
        }

        function createContentCard(item, type) {
            const card = document.createElement('div'); card.className = 'card';
            const title = type === 'movie' ? (item.title || item.original_name) : (item.name || item.original_name);
            const posterPath = item.poster_path ? `${TMDB_IMG_BASE_URL}${item.poster_path}` : 'https://placehold.co/180x270/1f1f1f/e50914?text=No+Poster';
            card.innerHTML = `
                <img src="${posterPath}" alt="${title} Poster" loading="lazy" onerror="this.onerror=null;this.src='https://placehold.co/180x270/1f1f1f/e50914?text=Error';">
                <div class="p-2"><h4 class="font-semibold truncate text-sm" title="${title}">${title}</h4><p class="text-xs text-gray-400">${type === 'movie' ? 'Movie' : 'TV Show'}</p></div>`;
            card.addEventListener('click', () => {
                if (type === 'movie') playMovie(item.id, title);
                else {
                    currentTvShow.id = item.id; currentTvShow.name = title; currentTvShow.season = 1; currentTvShow.episode = 1;
                    updateAndShowTVControlsInModal(); playTvShow(); 
                }
            });
            return card;
        }
        
        async function updateAndShowTVControlsInModal() {
            if (!currentTvShow.id) { modalTvControls.classList.add('hidden'); return; }
            modalTvShowTitleEl.textContent = currentTvShow.name || 'Selected TV Show';
            modalTvControls.classList.remove('hidden');
            modalSeasonSelect.disabled = true; modalEpisodeSelect.disabled = true;
            modalSeasonSelect.innerHTML = '<option>Loading...</option>'; modalEpisodeSelect.innerHTML = '<option>Loading...</option>';
            nextEpisodeButton.disabled = true;
            try {
                const tvDetails = await fetchFromTMDB(`tv/${currentTvShow.id}`);
                currentTvShow.totalSeasons = tvDetails.number_of_seasons;
                let validSeasons = tvDetails.seasons.filter(s => s.season_number > 0 && s.episode_count > 0);
                if (validSeasons.length === 0 && tvDetails.seasons.length > 0) validSeasons = tvDetails.seasons.filter(s => s.episode_count > 0); 
                populateDropdown(modalSeasonSelect, validSeasons, 'season_number', 'name', 'S');
                if (validSeasons.find(s => s.season_number === currentTvShow.season)) modalSeasonSelect.value = currentTvShow.season;
                else if (validSeasons.length > 0) { currentTvShow.season = validSeasons[0].season_number; modalSeasonSelect.value = currentTvShow.season; }
                modalSeasonSelect.disabled = false;
                await fetchEpisodesForModalSeason(currentTvShow.id, currentTvShow.season);
            } catch (error) { modalSeasonSelect.innerHTML = '<option>Error</option>'; modalEpisodeSelect.innerHTML = '<option>Error</option>'; }
        }
        
        async function fetchEpisodesForModalSeason(tvId, seasonNumber) {
            modalEpisodeSelect.disabled = true; modalEpisodeSelect.innerHTML = '<option>Loading...</option>';
            nextEpisodeButton.disabled = true; const cacheKey = `${tvId}-${seasonNumber}`;
            try {
                let seasonDetails;
                if (seasonDetailsCache[cacheKey]) seasonDetails = seasonDetailsCache[cacheKey];
                else { seasonDetails = await fetchFromTMDB(`tv/${tvId}/season/${seasonNumber}`); seasonDetailsCache[cacheKey] = seasonDetails; }
                currentTvShow.episodesInCurrentSeason = seasonDetails.episodes || [];
                populateDropdown(modalEpisodeSelect, currentTvShow.episodesInCurrentSeason, 'episode_number', 'name', 'E');
                if (currentTvShow.episodesInCurrentSeason.find(ep => ep.episode_number === currentTvShow.episode)) modalEpisodeSelect.value = currentTvShow.episode;
                else if (currentTvShow.episodesInCurrentSeason.length > 0) { currentTvShow.episode = currentTvShow.episodesInCurrentSeason[0].episode_number; modalEpisodeSelect.value = currentTvShow.episode; }
                modalEpisodeSelect.disabled = false; updateNextEpisodeButtonState();
            } catch (error) { modalEpisodeSelect.innerHTML = '<option>Error</option>'; }
        }

        function populateDropdown(selectEl, items, valueKey, textKey, prefix = '') {
            selectEl.innerHTML = '';
            if (!items || items.length === 0) { selectEl.innerHTML = `<option value="">N/A</option>`; return; }
            items.forEach(item => {
                const option = document.createElement('option'); option.value = item[valueKey];
                option.textContent = `${prefix}${item[valueKey]}${item[textKey] && item[textKey] !== `Episode ${item[valueKey]}` ? `: ${item[textKey]}` : ''}`;
                selectEl.appendChild(option);
            });
        }

        function updateNextEpisodeButtonState() {
            if (!currentTvShow.id || currentTvShow.episodesInCurrentSeason.length === 0) { nextEpisodeButton.disabled = true; return; }
            const currentEpisodeIndex = currentTvShow.episodesInCurrentSeason.findIndex(ep => ep.episode_number === currentTvShow.episode);
            const isLastEpisodeInSeason = currentEpisodeIndex === currentTvShow.episodesInCurrentSeason.length - 1;
            const isLastSeason = currentTvShow.season === currentTvShow.totalSeasons;
            nextEpisodeButton.disabled = isLastEpisodeInSeason && isLastSeason;
        }
        
        function playMovie(id, title) {
            modalTvControls.classList.add('hidden');
            const embedURL = `${ANYEMBED_BASE_URL}/movie/${id}?server=${DEFAULT_SERVER}`;
            playerModalTitle.textContent = title || 'Movie'; loadPlayer(embedURL);
        }

        function playTvShow() {
            if (!currentTvShow.id) return;
            modalTvControls.classList.remove('hidden'); 
            const embedURL = `${ANYEMBED_BASE_URL}/tv/${currentTvShow.id}/${currentTvShow.season}/${currentTvShow.episode}?server=${DEFAULT_SERVER}`;
            playerModalTitle.textContent = `${currentTvShow.name || 'TV Show'} (S${currentTvShow.season} E${currentTvShow.episode})`;
            loadPlayer(embedURL); updateNextEpisodeButtonState(); 
        }

        function loadPlayer(url) {
            const sandboxPermissions = ["allow-scripts", "allow-same-origin", "allow-forms", "allow-presentation", "allow-fullscreen"].join(" ");
            playerContainer.innerHTML = `<iframe src="${url}" sandbox="${sandboxPermissions}" allow="fullscreen; autoplay" allowfullscreen></iframe>`;
            playerModal.style.display = "block"; document.body.style.overflow = 'hidden';
        }

        function closePlayerModal() {
            playerModal.style.display = "none"; playerContainer.innerHTML = ""; 
            document.body.style.overflow = 'auto'; modalTvControls.classList.add('hidden'); 
        }
        
        function setSearchFilter(filterType, filterButtonContainer) {
            currentSearchFilter = filterType;
            filterButtonContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            filterButtonContainer.querySelector(`.filter-btn[data-filter="${filterType}"]`).classList.add('active');
        }

        [desktopSearchFilters, mobileSearchFilters].forEach(container => {
            container.addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    const filterType = e.target.dataset.filter;
                    setSearchFilter(filterType, desktopSearchFilters); 
                    setSearchFilter(filterType, mobileSearchFilters);
                    const query = desktopSearchInput.value.trim() || mobileSearchInput.value.trim();
                    if (searchResultsGridContainer.classList.contains('hidden') === false && query) { 
                        executeSearch(query);
                    }
                }
            });
        });
        
        desktopSearchButton.addEventListener('click', () => { executeSearch(desktopSearchInput.value.trim()); });
        desktopSearchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') executeSearch(desktopSearchInput.value.trim()); });
        mobileSearchButton.addEventListener('click', () => { 
            const query = mobileSearchInput.value.trim();
            if (query) { executeSearch(query); mobileMenu.classList.add('hidden');}
        });
        mobileSearchInput.addEventListener('keypress', (e) => { 
            if (e.key === 'Enter') {
                const query = mobileSearchInput.value.trim();
                if (query) { executeSearch(query); mobileMenu.classList.add('hidden'); }
            }
        });
        sortResultsSelect.addEventListener('change', sortAndDisplayResults);

        modalSeasonSelect.addEventListener('change', async () => {
            currentTvShow.season = parseInt(modalSeasonSelect.value); currentTvShow.episode = 1; 
            await fetchEpisodesForModalSeason(currentTvShow.id, currentTvShow.season); playTvShow();
        });
        modalEpisodeSelect.addEventListener('change', () => { currentTvShow.episode = parseInt(modalEpisodeSelect.value); playTvShow(); });
        nextEpisodeButton.addEventListener('click', async () => {
            if (!currentTvShow.id || nextEpisodeButton.disabled) return;
            const currentEpisodeIndex = currentTvShow.episodesInCurrentSeason.findIndex(ep => ep.episode_number === currentTvShow.episode);
            if (currentEpisodeIndex < currentTvShow.episodesInCurrentSeason.length - 1) {
                currentTvShow.episode = currentTvShow.episodesInCurrentSeason[currentEpisodeIndex + 1].episode_number;
                modalEpisodeSelect.value = currentTvShow.episode; playTvShow();
            } else if (currentTvShow.season < currentTvShow.totalSeasons) {
                currentTvShow.season++; currentTvShow.episode = 1; 
                modalSeasonSelect.value = currentTvShow.season; 
            }
        });

        closeModalButton.addEventListener('click', closePlayerModal);
        window.addEventListener('click', (event) => { if (event.target === playerModal) closePlayerModal(); });
        window.addEventListener('keydown', (event) => { if (event.key === 'Escape' && playerModal.style.display === 'block') closePlayerModal(); });

        function reinitializeScrollableContent() {
            moviesScrollWrapper = document.getElementById('moviesScrollWrapper');
            tvScrollWrapper = document.getElementById('tvScrollWrapper');
            document.querySelectorAll('.scroll-button').forEach(button => {
                button.removeEventListener('click', handleScrollButtonClick); 
                button.addEventListener('click', handleScrollButtonClick);
            });
             if(moviesScrollWrapper) {
                moviesScrollWrapper.removeEventListener('scroll', updateMoviesScrollButtons);
                moviesScrollWrapper.addEventListener('scroll', updateMoviesScrollButtons, { passive: true });
                updateScrollButtons(moviesScrollWrapper);
             }
             if(tvScrollWrapper) {
                tvScrollWrapper.removeEventListener('scroll', updateTvScrollButtons);
                tvScrollWrapper.addEventListener('scroll', updateTvScrollButtons, { passive: true });
                updateScrollButtons(tvScrollWrapper); 
             }
        }
        function updateMoviesScrollButtons() { updateScrollButtons(moviesScrollWrapper); }
        function updateTvScrollButtons() { updateScrollButtons(tvScrollWrapper); }
        
        homeLink.addEventListener('click', (e) => {
            e.preventDefault();
            desktopSearchInput.value = ''; mobileSearchInput.value = '';
            loadTopRatedContent(); 
        });
        
        mobileMenuButton.addEventListener('click', () => mobileMenu.classList.toggle('hidden'));
        navDiscoverMobile.addEventListener('click', (e) => { e.preventDefault(); mobileMenu.classList.add('hidden'); homeLink.click(); });

        function handleScrollButtonClick(event) {
            const button = event.currentTarget; const targetId = button.dataset.target;
            const scrollWrapper = document.getElementById(targetId); if (!scrollWrapper) return;
            const scrollAmount = scrollWrapper.clientWidth * 0.8; 
            if (button.classList.contains('next')) scrollWrapper.scrollLeft += scrollAmount;
            else if (button.classList.contains('prev')) scrollWrapper.scrollLeft -= scrollAmount;
        }
         function updateScrollButtons(scrollWrapper) {
            if (!scrollWrapper || !scrollWrapper.parentElement) return;
            const prevButton = scrollWrapper.parentElement.querySelector('.scroll-button.prev');
            const nextButton = scrollWrapper.parentElement.querySelector('.scroll-button.next');
            if(!prevButton || !nextButton) return;
            const isScrollable = scrollWrapper.scrollWidth > scrollWrapper.clientWidth;
            if (!isScrollable) { prevButton.style.display = 'none'; nextButton.style.display = 'none'; return; }
            prevButton.style.display = 'block'; nextButton.style.display = 'block';
            prevButton.disabled = scrollWrapper.scrollLeft <= 0;
            nextButton.disabled = scrollWrapper.scrollLeft + scrollWrapper.clientWidth >= scrollWrapper.scrollWidth - 5; 
        }

        document.getElementById('currentYear').textContent = new Date().getFullYear();
        reinitializeScrollableContent(); 
        loadTopRatedContent();

    </script>
</body>
</html>
