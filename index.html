<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OxyStream</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #E50914; /* Netflix Red */
            --secondary-color: #141414; /* Netflix Black */
            --card-bg-color: #222222;
            --text-color: #FFFFFF;
            --text-muted-color: #a0aec0; /* Tailwind gray-500 */
            --hover-color: #B20710; /* Darker Netflix Red */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--secondary-color);
        }
        ::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
            border: 2px solid var(--secondary-color);
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--hover-color);
        }

        .oxy-header {
            background-color: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(10px);
        }

        .oxy-title {
            color: var(--primary-color);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .oxy-input {
            background-color: #333;
            border: 1px solid #555;
            color: var(--text-color);
        }
        .oxy-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(229, 9, 20, 0.3);
        }
        .oxy-input:disabled {
            background-color: #444;
            cursor: not-allowed;
        }

        .oxy-btn {
            background-color: var(--primary-color);
            transition: background-color 0.3s ease;
        }
        .oxy-btn:hover {
            background-color: var(--hover-color);
        }
         .oxy-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
        }


        .oxy-btn-secondary {
            background-color: #4F4F4F;
        }
        .oxy-btn-secondary:hover {
            background-color: #6A6A6A;
        }

        .movie-card {
            background-color: var(--card-bg-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            overflow: hidden;
        }
        .movie-card:hover {
            transform: translateY(-8px) scale(1.03);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.5);
        }
        .movie-card img {
            aspect-ratio: 2 / 3;
            object-fit: cover;
        }
        .movie-card-title {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            min-height: 2.5em;
        }

        .section-title {
            color: var(--text-color);
            border-bottom: 2px solid var(--primary-color);
        }
        
        #iframePlayer {
            border: 3px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(229, 9, 20, 0.3);
        }

        /* Loading Spinner */
        .spinner {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 8px solid;
            border-color: #E50914 #0000; /* Red and transparent */
            animation: spinner-animation 1.2s infinite linear;
        }
        @keyframes spinner-animation {
            to {
                transform: rotate(360deg);
            }
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            color: white;
            z-index: 2000;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        .message-box.error {
            background-color: var(--primary-color);
        }
        .message-box.success {
            background-color: #28a745; /* Green for success */
        }

    </style>
</head>
<body class="bg-secondary-color text-text-color">

    <header class="oxy-header sticky top-0 z-50 p-4 shadow-lg">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <h1 class="oxy-title text-3xl sm:text-4xl mb-4 sm:mb-0 cursor-pointer" onclick="showTrendingView()">OxyStream</h1>
            <div class="flex w-full sm:w-auto">
                <input type="text" id="searchInput" class="oxy-input p-2 rounded-l-md flex-grow focus:outline-none" placeholder="Search by title (disabled)" disabled>
                <button id="searchButton" class="oxy-btn text-white p-2 rounded-r-md" disabled>Search</button>
            </div>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div id="loadingIndicator" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center z-[1000]" style="display: none;">
            <div class="spinner"></div>
        </div>

        <div id="messageBox" class="message-box"></div>

        <button id="backButton" class="oxy-btn-secondary text-white py-2 px-4 rounded-md mb-6 hidden" onclick="handleBack()">
            &larr; Back
        </button>

        <section id="trendingSection">
            <h2 class="section-title text-2xl font-semibold mb-6 pb-2">Trending TV Shows</h2>
            <div id="trendingGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
                </div>
        </section>

        <section id="contentDisplaySection" class="hidden mt-6">
            <h2 id="contentTitle" class="section-title text-2xl font-semibold mb-4 pb-2">Now Playing</h2>
            <div id="tvControls" class="mb-4 hidden flex-wrap gap-2 items-center">
                 <label for="seasonSelect" class="text-sm font-medium">Season:</label>
                 <select id="seasonSelect" class="oxy-select p-2 rounded-md bg-card-bg-color text-text-color w-auto"></select>
                 <label for="episodeSelect" class="text-sm font-medium">Episode:</label>
                 <select id="episodeSelect" class="oxy-select p-2 rounded-md bg-card-bg-color text-text-color w-auto"></select>
                 <button id="loadTvEpisodeButton" class="oxy-btn text-white py-2 px-3 rounded-md">Load Episode</button>
            </div>
            <div class="aspect-w-16 aspect-h-9">
                <iframe id="iframePlayer" class="w-full h-full rounded-lg" frameborder="0" allowfullscreen></iframe>
            </div>
        </section>
    </main>

    <footer class="text-center p-6 mt-8 border-t border-gray-700">
        <p class="text-text-muted-color">&copy; <span id="currentYear"></span> OxyStream. All rights reserved. API by moviesapi.to</p>
    </footer>

    <script>
        // API Configuration
        const API_BASE_URL = 'https://moviesapi.to'; // New API Base URL

        // Color constants for placeholders
        const PLACEHOLDER_BG_COLOR = '222222';
        const PLACEHOLDER_TEXT_COLOR = 'E50914';

        // DOM Elements
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const backButton = document.getElementById('backButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const messageBox = document.getElementById('messageBox');

        const trendingSection = document.getElementById('trendingSection');
        const trendingGrid = document.getElementById('trendingGrid');
        
        const contentDisplaySection = document.getElementById('contentDisplaySection');
        const contentTitle = document.getElementById('contentTitle');
        const iframePlayer = document.getElementById('iframePlayer');
        const tvControls = document.getElementById('tvControls');
        const seasonSelect = document.getElementById('seasonSelect');
        const episodeSelect = document.getElementById('episodeSelect');
        const loadTvEpisodeButton = document.getElementById('loadTvEpisodeButton');


        // State Management
        let currentView = 'trending';
        let previousView = 'trending';
        let currentMediaItem = null; // Stores the current movie/tv item from discover for context

        // --- Utility Functions ---
        function showLoading() { loadingIndicator.style.display = 'flex'; }
        function hideLoading() { loadingIndicator.style.display = 'none'; }

        function showMessage(message, type = 'error', duration = 4000) {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type} show`;
            setTimeout(() => { messageBox.classList.remove('show'); }, duration);
        }

        function updateView(viewToShow) {
            previousView = currentView;
            currentView = viewToShow;

            trendingSection.classList.add('hidden');
            contentDisplaySection.classList.add('hidden');
            backButton.classList.add('hidden');

            window.scrollTo(0, 0);

            switch (viewToShow) {
                case 'trending':
                    trendingSection.classList.remove('hidden');
                    break;
                case 'content':
                    contentDisplaySection.classList.remove('hidden');
                    backButton.classList.remove('hidden');
                    break;
            }
        }

        async function fetchData(url, errorMessagePrefix = 'Failed to fetch data') {
            showLoading();
            let response;
            try {
                response = await fetch(url, { mode: 'cors' });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: `API returned status ${response.status}: ${response.statusText || 'No additional error message provided.'}` }));
                    throw new Error(`${errorMessagePrefix}: ${errorData.message || `HTTP error ${response.status}`}`);
                }
                return await response.json();
            } catch (error) {
                if (error instanceof TypeError && error.message === 'Failed to fetch') {
                    console.error(`[${errorMessagePrefix}] Network Error: "${error.message}". Potential causes: Internet issue, DNS failure, API server down/unresponsive (${url}), or CORS policy. Check browser's Network tab.`);
                } else {
                    console.error(`[${errorMessagePrefix}] Full error object:`, error);
                    console.error(`[${errorMessagePrefix}] Error name: ${error.name}, Message: ${error.message}`);
                }
                if (response) {
                    console.error(`[${errorMessagePrefix}] HTTP Status from server: ${response.status} ${response.statusText}`);
                }

                let displayMessage = `${errorMessagePrefix}. Check connection or try later. Details in console.`;
                if (error.message) {
                    const prefixPattern = `${errorMessagePrefix}: `;
                    let apiSpecificMessage = error.message.startsWith(prefixPattern) ? error.message.substring(prefixPattern.length) : error.message;
                    if (apiSpecificMessage === "Failed to fetch") {
                         displayMessage = `${errorMessagePrefix}: Network error or API unreachable. Check internet and try again. API service might be down or CORS issue (see console).`;
                    } else if (apiSpecificMessage === "{}") {
                         displayMessage = `${errorMessagePrefix}: API returned an unclear error. Check console.`;
                    } else {
                        displayMessage = error.message.startsWith(prefixPattern) ? error.message : `${errorMessagePrefix}: ${apiSpecificMessage}`;
                    }
                }
                showMessage(displayMessage);
                return null;
            } finally {
                hideLoading();
            }
        }

        // --- Rendering Functions ---
        function createMediaCard(item, mediaType) {
            const card = document.createElement('div');
            card.className = 'movie-card rounded-lg shadow-md cursor-pointer flex flex-col';
            
            // Assumption: The discover API provides 'poster_path' or 'backdrop_path' relative to a base image URL,
            // or a full 'image' URL. For moviesapi.to, it's often direct image links in 'poster' or 'backdrop'.
            // Let's assume 'poster' or 'backdrop' field exists and is a full URL.
            // If not, this needs adjustment based on actual API response.
            // A common pattern is TMDB-like, where you get a path and prepend a base URL.
            // For now, I'll try `item.poster` then `item.backdrop`, then a placeholder.
            // The actual field names from moviesapi.to/api/discover/* need to be verified.
            // Let's tentatively use `item.poster_path` and assume a TMDB-like structure for image paths if `item.image` isn't direct.
            // For now, I'll use a generic placeholder as the exact image field is unknown.
            // A common field name is `poster_url` or `thumbnail_url` or just `image`.
            // Let's assume the API returns a field named `image` with the full URL.
            const imageUrl = item.image || item.poster || item.backdrop_path || `https://placehold.co/400x600/${PLACEHOLDER_BG_COLOR}/${PLACEHOLDER_TEXT_COLOR}?text=No+Image`;
            const errorImage = `https://placehold.co/400x600/${PLACEHOLDER_BG_COLOR}/${PLACEHOLDER_TEXT_COLOR}?text=Error`;

            card.innerHTML = `
                <img src="${imageUrl}" alt="${item.title}" class="w-full h-auto rounded-t-lg" onerror="this.onerror=null;this.src='${errorImage}';">
                <div class="p-3 flex flex-col flex-grow">
                    <h3 class="text-md font-semibold movie-card-title text-ellipsis overflow-hidden">${item.title || 'Untitled'}</h3>
                    ${item.year ? `<p class="text-xs text-text-muted-color mt-auto">(${item.year})</p>` : ''}
                </div>
            `;
            // Store mediaType with the item if not already present
            const itemWithtype = {...item, media_type: mediaType };
            card.addEventListener('click', () => showContentInIframe(itemWithtype));
            return card;
        }

        function displayMedia(items, containerElement, mediaType) {
            containerElement.innerHTML = '';
            if (!items || items.length === 0) {
                containerElement.innerHTML = `<p class="col-span-full text-center text-text-muted-color p-8">No content available at the moment.</p>`;
                return;
            }
            // The new API might return data directly as an array or nested under a 'results' key.
            // Adjusting to expect an array directly based on common discover patterns.
            // If it's under 'results', then items.results.forEach(...) would be needed.
            // For now, assuming 'items' is the array.
            items.forEach(item => containerElement.appendChild(createMediaCard(item, mediaType)));
        }

        // --- Main Logic Functions ---
        async function showTrendingView() {
            // Fetching trending TV shows as an example
            // The actual response structure from moviesapi.to/api/discover/tv needs to be known.
            // Assuming it returns an array of TV show objects.
            const data = await fetchData(`${API_BASE_URL}/api/discover/tv`, 'Failed to load trending TV shows');
            if (data) { // Assuming data is the array of items, or data.results if nested
                displayMedia(data.results || data, trendingGrid, 'tv'); // Pass 'tv' as mediaType
            }
            updateView('trending');
        }
        
        // Search functionality is disabled for now
        // searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') performSearch(); });
        // searchButton.addEventListener('click', performSearch);


        function showContentInIframe(item) {
            currentMediaItem = item; // Store the item for context (e.g., if we add S/E selection)
            contentTitle.textContent = `Now Playing: ${item.title || 'Content'}`;
            let iframeSrc = '';

            if (item.media_type === 'movie' && item.id) {
                iframeSrc = `${API_BASE_URL}/movie/${item.id}`;
                tvControls.classList.add('hidden');
            } else if (item.media_type === 'tv' && item.id) {
                // Default to Season 1, Episode 1 for TV shows
                // A more robust solution would fetch season/episode data if the API provides it
                // and populate the selectors.
                const defaultSeason = 1;
                const defaultEpisode = 1;
                
                // Populate season/episode selectors (basic example, assumes max 10 seasons/50 episodes)
                // This should ideally be based on actual data from the API if available
                seasonSelect.innerHTML = Array.from({length: 10}, (_, i) => `<option value="${i+1}">Season ${i+1}</option>`).join('');
                episodeSelect.innerHTML = Array.from({length: 50}, (_, i) => `<option value="${i+1}">Episode ${i+1}</option>`).join('');
                seasonSelect.value = defaultSeason;
                episodeSelect.value = defaultEpisode;

                iframeSrc = `${API_BASE_URL}/tv/${item.id}-${defaultSeason}-${defaultEpisode}`;
                tvControls.classList.remove('hidden');
            } else {
                showMessage('Could not determine content type or ID.', 'error');
                updateView('trending'); // Go back if we can't play
                return;
            }

            if (iframeSrc) {
                iframePlayer.src = iframeSrc;
                updateView('content');
            }
        }
        
        loadTvEpisodeButton.addEventListener('click', () => {
            if (currentMediaItem && currentMediaItem.media_type === 'tv' && currentMediaItem.id) {
                const season = seasonSelect.value;
                const episode = episodeSelect.value;
                if (season && episode) {
                    const iframeSrc = `${API_BASE_URL}/tv/${currentMediaItem.id}-${season}-${episode}`;
                    iframePlayer.src = iframeSrc;
                    contentTitle.textContent = `Now Playing: ${currentMediaItem.title} (S${season} E${episode})`;
                    // No need to call updateView if already in 'content' view
                } else {
                    showMessage('Please select a valid season and episode.', 'error');
                }
            }
        });


        function handleBack() {
            iframePlayer.src = 'about:blank'; // Stop iframe content
            tvControls.classList.add('hidden'); // Hide TV controls
            currentMediaItem = null; // Clear current item

            if (currentView === 'content') {
                updateView(previousView || 'trending'); // Go to previous view or trending
            } else {
                showTrendingView(); // Fallback
            }
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('currentYear').textContent = new Date().getFullYear();
            showTrendingView();
        });

    </script>
</body>
</html>
